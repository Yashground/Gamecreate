<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shape Shift Runner</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: #121212;
    }
    #canvas {
        display: block;
    }
    #score {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #ffffff;
        font-size: 24px;
        font-family: Arial, sans-serif;
    }
    #instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ffffff;
        font-size: 24px;
        font-family: Arial, sans-serif;
        text-align: center;
    }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="score"></div>
<div id="instructions">Press 'E' or Tap to toggle shapes.<br>Match your shape with the tunnel's shape!</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const instructions = document.getElementById('instructions');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gameOver = false;
let speed = 2;
let score = 0;
let highScore = localStorage.getItem('highScore') || 0;
let successfulPasses = 0;
let playerY = canvas.height / 2;
let isJumping = false;
let jumpHeight = 0;
let raindrops = [];
let restartTimer;

const shapes = ['circle', 'triangle', 'square'];
let playerShape = 'circle';
let tunnelQueue = [];
let frameCount = 0;
let spawnInterval = 250;
let minSpacing = 400;
let cloudX = canvas.width;
let leafX = canvas.width + 100;

const toggleSound = new Audio('76376__deleted_user_877451__game_over.wav');
const passSound = new Audio('414436__inspectorj__dropping-metal-pin-on-wood-b.wav');
const gameOverSound = new Audio('76376__deleted_user_877451__game_over.wav');

// Add both keyboard and touch event listeners
document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'e') {
        toggleShape();
    }
    if ((e.key === 'ArrowUp' || e.key === 'w') && !isJumping) {
        isJumping = true;
        jumpHeight = -150;  // Jump up
    }
});

// Add touch event listener for mobile devices
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();  // Prevent scrolling on mobile
    toggleShape();  // Trigger shape change on touch
});

// Add an event listener to reset the game on click after a game over.
canvas.addEventListener('click', () => {
    if (gameOver) resetGame();
});

function toggleShape() {
    const currentIndex = shapes.indexOf(playerShape);
    playerShape = shapes[(currentIndex + 1) % shapes.length];
    toggleSound.play();
}

function drawNeonShape(x, y, size, color, shapeType) {
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 10;

    ctx.save();
    ctx.translate(x, y);

    if (shapeType === 'circle') {
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
    } else if (shapeType === 'triangle') {
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size, size);
        ctx.lineTo(-size, size);
        ctx.closePath();
        ctx.fill();
    } else if (shapeType === 'square') {
        ctx.fillRect(-size, -size, size * 2, size * 2);
    }

    ctx.restore();
    ctx.shadowBlur = 0;  // Remove the glow effect after drawing
}

function drawPlayer() {
    drawNeonShape(canvas.width / 4, playerY, 50, '#00ffcc', playerShape);
}

function drawRoad() {
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2 + 100);
    ctx.lineTo(canvas.width, canvas.height / 2 + 100);
    ctx.stroke();
}

function drawPixelArtCloudsAndLeaves() {
    // Clouds as overlapping circles
    ctx.fillStyle = '#ffffff';
    drawCloud(cloudX, 100, 50);
    drawCloud(cloudX + 200, 70, 40);

    // Leaves
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(leafX, 80, 15, 0, Math.PI * 2);
    ctx.arc(leafX + 20, 90, 10, 0, Math.PI * 2);
    ctx.arc(leafX + 40, 80, 15, 0, Math.PI * 2);
    ctx.fill();

    cloudX -= 1;
    leafX -= 1;

    if (cloudX < -150) cloudX = canvas.width;
    if (leafX < -100) leafX = canvas.width + 100;
}

function drawCloud(x, y, size) {
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.arc(x - size * 0.7, y + size * 0.3, size * 0.6, 0, Math.PI * 2);
    ctx.arc(x + size * 0.7, y + size * 0.3, size * 0.6, 0, Math.PI * 2);
    ctx.arc(x - size * 0.4, y - size * 0.5, size * 0.4, 0, Math.PI * 2);
    ctx.arc(x + size * 0.4, y - size * 0.5, size * 0.4, 0, Math.PI * 2);
    ctx.fill();
}

function spawnTunnel() {
    const tunnelShape = shapes[Math.floor(Math.random() * shapes.length)];
    const lastTunnel = tunnelQueue[tunnelQueue.length - 1];
    const lastX = lastTunnel ? lastTunnel.x : canvas.width + minSpacing;

    tunnelQueue.push({
        shape: tunnelShape,
        x: lastX + minSpacing + Math.random() * 100,
        y: canvas.height / 2,
        passed: false,
    });
}

function drawTunnel(tunnel) {
    drawNeonShape(tunnel.x, tunnel.y, 60, '#ff0066', tunnel.shape);
}

function updateTunnels() {
    tunnelQueue.forEach((tunnel, index) => {
        tunnel.x -= speed;

        if (!tunnel.passed && tunnel.x < canvas.width / 4) {
            if (tunnel.shape === playerShape) {
                score++;
                successfulPasses++;
                passSound.play();
                tunnel.passed = true;

                if (successfulPasses % 4 === 0) {
                    isJumping = true;  // Activate jump power-up every 4 successful passes
                }

                if (successfulPasses % 5 === 0) {
                    speed += 0.5;  // Increase speed every 5 successful passes
                }
            } else {
                gameOverSound.play();
                breakShapeAndTunnel();
                endGame();
            }
        }

        if (tunnel.x < -100) {
            tunnelQueue.splice(index, 1);
        }
    });
}

function breakShapeAndTunnel() {
    // Breaking the player shape and tunnel into pieces when game ends
    for (let i = 0; i < 10; i++) {
        drawNeonShape(canvas.width / 4 + (Math.random() * 50 - 25), playerY + (Math.random() * 50 - 25), 10, '#ff0066', playerShape);
        drawNeonShape(tunnelQueue[0].x + (Math.random() * 50 - 25), tunnelQueue[0].y + (Math.random() * 50 - 25), 10, '#ff0066', tunnelQueue[0].shape);
    }
}

function applyJump() {
    if (isJumping) {
        playerY += jumpHeight;
        jumpHeight += 10;  // Gravity

        if (jumpHeight > 0 && playerY >= canvas.height / 2) {
            playerY = canvas.height / 2;
            isJumping = false;
        }
    }
}

function drawRain() {
    raindrops.forEach(drop => {
        ctx.beginPath();
        ctx.arc(drop.x, drop.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#00f';
        ctx.fill();
        drop.y += 5;

        if (drop.y > canvas.height) {
            drop.y = 0;
            drop.x = Math.random() * canvas.width;
        }
    });
}

function spawnRain() {
    // Create raindrops if they don't exist
    if (raindrops.length === 0) {
        for (let i = 0; i < 20; i++) {
            raindrops.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height / 2
            });
        }
    }
}

function endGame() {
    gameOver = true;
    instructions.style.display = 'block';
    instructions.innerHTML = `Game Over! Final Score: ${score}<br>High Score: ${highScore}<br>Click to Restart`;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
    }

    restartTimer = setTimeout(() => {
        resetGame();
    }, 3000);
}

function resetGame() {
    clearTimeout(restartTimer);
    gameOver = false;
    score = 0;
    speed = 2;
    playerY = canvas.height / 2;
    tunnelQueue = [];
    frameCount = 0;
    successfulPasses = 0;
    instructions.style.display = 'none';
    gameLoop();
}

function gameLoop() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawPlayer();
    drawRoad();
    drawPixelArtCloudsAndLeaves();
    updateTunnels();
    applyJump();
    tunnelQueue.forEach(drawTunnel);
    drawRain();

    scoreElement.innerText = `Score: ${score}`;

    frameCount++;
    if (frameCount % spawnInterval === 0) {
        spawnTunnel();
    }

    requestAnimationFrame(gameLoop);
}

function startGame() {
    instructions.style.display = 'none';
    spawnRain();  // Start the rain effect
    gameLoop();
}

setTimeout(startGame, 3000);
</script>
</body>
</html>
